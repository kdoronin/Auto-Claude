name: AC Review Labels

# Adds "Missing AC Approval" on PR open, updates labels on AC review
on:
  pull_request_target:
    types: [opened, reopened]
  issue_comment:
    types: [created]

permissions:
  pull-requests: write
  contents: read

concurrency:
  group: ac-labels-${{ github.event.pull_request.number || github.event.issue.number }}
  cancel-in-progress: true

jobs:
  # Add "Missing AC Approval" when PR is opened
  initial-label:
    name: Initial Label
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request_target'
    timeout-minutes: 5

    steps:
      - name: Add Missing AC Approval label
        uses: actions/github-script@v7
        with:
          retries: 3
          script: |
            const { owner, repo } = context.repo;
            const prNumber = context.payload.pull_request.number;

            console.log(`PR #${prNumber} - Adding initial label`);

            // Check if already has any AC label
            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner, repo, issue_number: prNumber
            });
            const labelNames = labels.map(l => l.name);

            const AC_LABELS = ['Missing AC Approval', 'AC: Approved', 'AC: Changes Requested', 'AC: Blocked'];
            const hasACLabel = AC_LABELS.some(l => labelNames.includes(l));

            if (hasACLabel) {
              console.log('Already has an AC label, skipping');
              return;
            }

            await github.rest.issues.addLabels({
              owner, repo, issue_number: prNumber, labels: ['Missing AC Approval']
            });

            console.log('‚úÖ Added "Missing AC Approval" label');

  # Detect AC review or @AutoClaudeCheck command
  ac-review:
    name: AC Review Detection
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issue_comment' &&
      github.event.issue.pull_request
    timeout-minutes: 5

    steps:
      - name: Process comment
        uses: actions/github-script@v7
        with:
          retries: 3
          script: |
            const AC_LABELS = ['Missing AC Approval', 'AC: Approved', 'AC: Changes Requested', 'AC: Blocked'];

            // Patterns that identify Auto-Claude review comments
            const AC_REVIEW_PATTERNS = [
              'Generated by Auto Claude PR Review',
              'Auto Claude PR Review',
              'Auto-Claude Review'
            ];

            // Trusted sources
            const TRUSTED_BOTS = ['github-actions[bot]', 'auto-claude[bot]'];
            const TRUSTED_ASSOC = ['COLLABORATOR', 'MEMBER', 'OWNER'];

            const { owner, repo } = context.repo;
            const prNumber = context.payload.issue.number;
            const comment = context.payload.comment;
            const body = (comment.body || '').slice(0, 5000);

            // Check if from trusted source
            const isTrustedBot = TRUSTED_BOTS.includes(comment.user.login) && comment.user.type === 'Bot';
            const isTrustedUser = TRUSTED_ASSOC.includes(comment.author_association);

            // === Handle @AutoClaudeCheck command ===
            if (body.includes('@AutoClaudeCheck')) {
              if (!isTrustedBot && !isTrustedUser) {
                console.log('Ignoring @AutoClaudeCheck from non-trusted source');
                return;
              }

              console.log(`PR #${prNumber} - @AutoClaudeCheck command`);

              // Get PR details
              const { data: pr } = await github.rest.pulls.get({
                owner, repo, pull_number: prNumber
              });

              // Get current labels
              const { data: labels } = await github.rest.issues.listLabelsOnIssue({
                owner, repo, issue_number: prNumber
              });
              const labelNames = labels.map(l => l.name);
              const currentACLabel = AC_LABELS.find(l => labelNames.includes(l)) || 'None';

              // Get all comments to find latest AC review
              const { data: comments } = await github.rest.issues.listComments({
                owner, repo, issue_number: prNumber, per_page: 100
              });

              let latestVerdict = null;
              let latestTime = 0;

              for (const c of comments) {
                const cBody = (c.body || '').slice(0, 5000);
                const isAC = AC_REVIEW_PATTERNS.some(p => cBody.includes(p));
                if (!isAC) continue;

                let verdict = null;
                if (/Merge Verdict:\s*‚úÖ/.test(cBody) || cBody.includes('READY TO MERGE')) {
                  verdict = 'AC: Approved';
                } else if (/Merge Verdict:\s*üü°/.test(cBody) || cBody.includes('MERGE WITH CHANGES')) {
                  verdict = 'AC: Approved';
                } else if (/Merge Verdict:\s*üü†/.test(cBody) || cBody.includes('NEEDS REVISION')) {
                  verdict = 'AC: Changes Requested';
                } else if (/Merge Verdict:\s*üî¥/.test(cBody) || cBody.includes('BLOCKED')) {
                  verdict = 'AC: Blocked';
                }

                if (verdict) {
                  const t = new Date(c.created_at).getTime();
                  if (t > latestTime) {
                    latestVerdict = verdict;
                    latestTime = t;
                  }
                }
              }

              // Update label if needed
              if (latestVerdict && !labelNames.includes(latestVerdict)) {
                for (const l of AC_LABELS) {
                  if (labelNames.includes(l)) {
                    try { await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: l }); } catch (e) {}
                  }
                }
                await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: [latestVerdict] });
                console.log(`Updated label to: ${latestVerdict}`);
              }

              // Post status report
              const statusEmoji = latestVerdict === 'AC: Approved' ? '‚úÖ' :
                                  latestVerdict === 'AC: Changes Requested' ? 'üü†' :
                                  latestVerdict === 'AC: Blocked' ? 'üî¥' : '‚è≥';

              const report = [
                `## ${statusEmoji} PR Status Report`,
                '',
                '| Item | Status |',
                '|------|--------|',
                `| AC Review | ${latestVerdict || 'No review yet'} |`,
                `| Current Label | ${latestVerdict || currentACLabel} |`,
                '',
                '---',
                `<sub>Triggered by \`@AutoClaudeCheck\` from @${comment.user.login}</sub>`
              ].join('\n');

              await github.rest.issues.createComment({
                owner, repo, issue_number: prNumber, body: report
              });

              console.log('‚úÖ Posted status report');
              return;
            }

            // === Handle AC Review comment ===
            if (!isTrustedBot && !isTrustedUser) {
              console.log(`Skipping: not a trusted source (${comment.user.login})`);
              return;
            }

            const isACReview = AC_REVIEW_PATTERNS.some(p => body.includes(p));
            if (!isACReview) {
              console.log('Skipping: not an Auto-Claude review comment');
              return;
            }

            console.log(`PR #${prNumber} - Processing Auto-Claude review`);

            // Parse verdict
            let verdict = null;
            if (/Merge Verdict:\s*‚úÖ/.test(body) || body.includes('READY TO MERGE')) {
              verdict = 'AC: Approved';
            } else if (/Merge Verdict:\s*üü°/.test(body) || body.includes('MERGE WITH CHANGES')) {
              verdict = 'AC: Approved';
            } else if (/Merge Verdict:\s*üü†/.test(body) || body.includes('NEEDS REVISION')) {
              verdict = 'AC: Changes Requested';
            } else if (/Merge Verdict:\s*üî¥/.test(body) || body.includes('BLOCKED')) {
              verdict = 'AC: Blocked';
            }

            if (!verdict) {
              console.log('Could not parse verdict');
              return;
            }

            console.log(`Detected verdict: ${verdict}`);

            // Get current labels
            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner, repo, issue_number: prNumber
            });
            const labelNames = labels.map(l => l.name);

            if (labelNames.includes(verdict)) {
              console.log(`Label "${verdict}" already present`);
              return;
            }

            // Remove old AC labels and add new one
            for (const l of AC_LABELS) {
              if (labelNames.includes(l)) {
                try { await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: l }); } catch (e) {}
              }
            }

            await github.rest.issues.addLabels({
              owner, repo, issue_number: prNumber, labels: [verdict]
            });

            console.log(`‚úÖ Added label: ${verdict}`);
