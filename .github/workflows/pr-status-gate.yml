name: PR Status Gate

# SINGLE WORKFLOW for ALL PR labeling
# Handles: Size, Area, Type, CI Status, AC Review labels
on:
  # Immediate: When PR is opened/updated - add size/area/type labels
  pull_request_target:
    types: [opened, synchronize, reopened]

  # Fast: When CI workflows complete - update status labels quickly
  workflow_run:
    workflows: [CI, Lint, Quality Security]
    types: [completed]

  # Manual: @AutoClaudeCheck comment trigger
  issue_comment:
    types: [created]

  # Scheduled: Catch-up for missed updates, 3-min AC label, 30-min auto-check
  schedule:
    - cron: '*/5 * * * *'

permissions:
  pull-requests: write
  checks: read
  contents: read

# Concurrency: Only one run per PR at a time to prevent race conditions
concurrency:
  group: pr-gate-${{ github.event.pull_request.number || github.event.workflow_run.pull_requests[0].number || github.event.issue.number || github.run_id }}
  cancel-in-progress: true

jobs:
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # IMMEDIATE LABELING (on PR open/sync) - Size, Area, Type
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  immediate-labels:
    name: Immediate Labels
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request_target'
    timeout-minutes: 5

    steps:
      - name: Add size/area/type labels
        uses: actions/github-script@v7
        with:
          retries: 3
          script: |
            const CONFIG = {
              SIZE_THRESHOLDS: { XS: 10, S: 100, M: 500, L: 1000 },
              TYPE_MAP: {
                'feat': 'feature', 'fix': 'bug', 'docs': 'documentation',
                'refactor': 'refactor', 'test': 'test', 'ci': 'ci',
                'chore': 'chore', 'perf': 'performance', 'style': 'style', 'build': 'build'
              },
              AREA_PATHS: { frontend: 'apps/frontend/', backend: 'apps/backend/', ci: '.github/' },
              SIZE_LABELS: ['size/XS', 'size/S', 'size/M', 'size/L', 'size/XL'],
              AREA_LABELS: ['area/frontend', 'area/backend', 'area/fullstack', 'area/ci']
            };

            const { owner, repo } = context.repo;
            const pr = context.payload.pull_request;
            const prNumber = pr.number;
            const title = pr.title || '';

            console.log(`PR #${prNumber} - Immediate labeling`);

            const labelsToAdd = [];
            const labelsToRemove = [];

            // 1. Type label from conventional commit
            const match = title.slice(0, 200).match(/^(\w{1,20})(\([^)]{0,50}\))?(!)?:/);
            if (match) {
              const type = match[1].toLowerCase();
              if (CONFIG.TYPE_MAP[type]) {
                labelsToAdd.push(CONFIG.TYPE_MAP[type]);
                console.log(`  Type: ${type} ‚Üí ${CONFIG.TYPE_MAP[type]}`);
              }
              if (match[3] === '!') labelsToAdd.push('breaking-change');
            }

            // 2. Area label from changed files
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner, repo, pull_number: prNumber, per_page: 100
            });
            
            const areas = { frontend: false, backend: false, ci: false };
            for (const file of files) {
              if (file.filename.startsWith(CONFIG.AREA_PATHS.frontend)) areas.frontend = true;
              if (file.filename.startsWith(CONFIG.AREA_PATHS.backend)) areas.backend = true;
              if (file.filename.startsWith(CONFIG.AREA_PATHS.ci)) areas.ci = true;
            }
            
            let areaLabel = null;
            if (areas.frontend && areas.backend) areaLabel = 'area/fullstack';
            else if (areas.frontend) areaLabel = 'area/frontend';
            else if (areas.backend) areaLabel = 'area/backend';
            else if (areas.ci) areaLabel = 'area/ci';
            
            if (areaLabel) {
              labelsToAdd.push(areaLabel);
              CONFIG.AREA_LABELS.filter(l => l !== areaLabel).forEach(l => labelsToRemove.push(l));
              console.log(`  Area: ${areaLabel}`);
            }

            // 3. Size label
            const totalLines = (pr.additions || 0) + (pr.deletions || 0);
            let sizeLabel = 'size/XL';
            if (totalLines < CONFIG.SIZE_THRESHOLDS.XS) sizeLabel = 'size/XS';
            else if (totalLines < CONFIG.SIZE_THRESHOLDS.S) sizeLabel = 'size/S';
            else if (totalLines < CONFIG.SIZE_THRESHOLDS.M) sizeLabel = 'size/M';
            else if (totalLines < CONFIG.SIZE_THRESHOLDS.L) sizeLabel = 'size/L';
            
            labelsToAdd.push(sizeLabel);
            CONFIG.SIZE_LABELS.filter(l => l !== sizeLabel).forEach(l => labelsToRemove.push(l));
            console.log(`  Size: ${sizeLabel} (${totalLines} lines)`);

            // 4. Add initial status label on new PRs
            if (context.payload.action === 'opened' || context.payload.action === 'reopened') {
              labelsToAdd.push('üîÑ Checking');
              console.log(`  Status: üîÑ Checking (new PR)`);
            }

            // Apply labels
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner, repo, issue_number: prNumber
            });
            const currentNames = currentLabels.map(l => l.name);

            // Remove old labels
            for (const label of labelsToRemove) {
              if (currentNames.includes(label)) {
                try {
                  await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: label });
                } catch (e) { /* ignore */ }
              }
            }

            // Add new labels (filter out already present)
            const toAdd = labelsToAdd.filter(l => !currentNames.includes(l));
            if (toAdd.length > 0) {
              await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: toAdd });
              console.log(`  Added: ${toAdd.join(', ')}`);
            }

            console.log(`‚úÖ PR #${prNumber} labeled`);

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # CI STATUS UPDATE (on workflow completion) - Fast status update
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  ci-status-update:
    name: CI Status Update
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_run' && github.event.workflow_run.pull_requests[0] != null
    timeout-minutes: 5

    steps:
      - name: Update CI status label
        uses: actions/github-script@v7
        with:
          retries: 3
          script: |
            const STATUS = { CHECKING: 'üîÑ Checking', PASSED: '‚úÖ Ready for Review', FAILED: '‚ùå Checks Failed' };
            
            // Required checks - use partial matching to handle "(pull_request)" suffix
            const REQUIRED_PATTERNS = [
              'CI / test-frontend',
              'CI / test-python (3.12)',
              'CI / test-python (3.13)',
              'Lint / python',
              'Quality Security / CodeQL (javascript-typescript)',
              'Quality Security / CodeQL (python)',
              'Quality Security / Python Security (Bandit)',
              'Quality Security / Security Summary'
            ];

            const { owner, repo } = context.repo;
            const prNumber = context.payload.workflow_run.pull_requests[0].number;
            const headSha = context.payload.workflow_run.head_sha;

            console.log(`PR #${prNumber} - CI status update (SHA: ${headSha.slice(0, 8)})`);

            // Fetch all check runs
            const checkRuns = await github.paginate(
              github.rest.checks.listForRef,
              { owner, repo, ref: headSha, per_page: 100 },
              (response) => response.data
            );

            // Log all check runs for debugging
            console.log(`Found ${checkRuns.length} check runs:`);
            for (const c of checkRuns.slice(0, 20)) {
              console.log(`  - ${c.name}: ${c.status} / ${c.conclusion}`);
            }

            // Match checks using includes (more flexible matching)
            let allComplete = true;
            let anyFailed = false;
            let matchedCount = 0;

            for (const pattern of REQUIRED_PATTERNS) {
              // Try exact startsWith first, then includes for flexibility
              let check = checkRuns.find(c => c.name.startsWith(pattern));
              if (!check) {
                // Try partial match (check name contains pattern without the "Quality Security / " prefix etc)
                const shortPattern = pattern.split(' / ').pop();
                check = checkRuns.find(c => c.name.includes(shortPattern));
              }
              
              if (!check) {
                console.log(`  ‚ö†Ô∏è ${pattern}: NOT FOUND (skipping)`);
                // Don't fail if check doesn't exist - it might be a matrix variation
                continue;
              }
              
              matchedCount++;
              if (check.status !== 'completed') {
                allComplete = false;
                console.log(`  üîÑ ${pattern}: running`);
              } else if (check.conclusion !== 'success' && check.conclusion !== 'skipped') {
                anyFailed = true;
                console.log(`  ‚ùå ${pattern}: ${check.conclusion}`);
              } else {
                console.log(`  ‚úÖ ${pattern}: ${check.conclusion}`);
              }
            }

            console.log(`Matched ${matchedCount}/${REQUIRED_PATTERNS.length} required checks`);

            // Determine new status
            // Need at least 3 checks to be found and complete to mark as ready
            let newStatus = STATUS.CHECKING;
            if (allComplete && matchedCount >= 3) {
              newStatus = anyFailed ? STATUS.FAILED : STATUS.PASSED;
            } else if (matchedCount === 0) {
              console.log('No required checks found yet, staying in Checking');
            }

            // Get current labels and check if update needed
            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner, repo, issue_number: prNumber
            });
            const labelNames = labels.map(l => l.name);
            const currentStatus = Object.values(STATUS).find(s => labelNames.includes(s));

            if (currentStatus === newStatus) {
              console.log(`Status already ${newStatus}, skipping`);
              return;
            }

            // Update status label
            for (const status of Object.values(STATUS)) {
              if (labelNames.includes(status)) {
                try {
                  await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: status });
                } catch (e) { /* ignore */ }
              }
            }
            
            await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: [newStatus] });
            console.log(`‚úÖ Status updated: ${currentStatus || 'none'} ‚Üí ${newStatus}`);

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # @AutoClaudeCheck COMMAND - Manual status check
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  manual-check:
    name: Manual Check (@AutoClaudeCheck)
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issue_comment' &&
      github.event.issue.pull_request &&
      contains(github.event.comment.body, '@AutoClaudeCheck')
    timeout-minutes: 5

    steps:
      - name: Run status check and post report
        uses: actions/github-script@v7
        with:
          retries: 3
          script: |
            const STATUS = { CHECKING: 'üîÑ Checking', PASSED: '‚úÖ Ready for Review', FAILED: '‚ùå Checks Failed' };
            const REVIEW_LABELS = ['Missing AC Approval', 'AC: Approved', 'AC: Changes Requested', 'AC: Blocked', 'AC: Needs Re-review'];
            const REQUIRED_PATTERNS = [
              'CI / test-frontend',
              'CI / test-python (3.12)',
              'CI / test-python (3.13)',
              'Lint / python',
              'Quality Security / CodeQL (javascript-typescript)',
              'Quality Security / CodeQL (python)',
              'Quality Security / Python Security (Bandit)',
              'Quality Security / Security Summary'
            ];

            const { owner, repo } = context.repo;
            const prNumber = context.payload.issue.number;
            const requestedBy = context.payload.comment.user.login;

            console.log(`PR #${prNumber} - @AutoClaudeCheck by @${requestedBy}`);

            // Get PR details
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            const headSha = pr.head.sha;

            // Fetch check runs
            const checkRuns = await github.paginate(
              github.rest.checks.listForRef,
              { owner, repo, ref: headSha, per_page: 100 },
              (response) => response.data
            );

            // Analyze checks
            const results = [];
            let allComplete = true;
            let anyFailed = false;

            for (const pattern of REQUIRED_PATTERNS) {
              const check = checkRuns.find(c => c.name.startsWith(pattern));
              if (!check) {
                results.push({ name: pattern, emoji: '‚è≥' });
                allComplete = false;
              } else if (check.status !== 'completed') {
                results.push({ name: pattern, emoji: 'üîÑ' });
                allComplete = false;
              } else if (check.conclusion === 'success' || check.conclusion === 'skipped') {
                results.push({ name: pattern, emoji: check.conclusion === 'skipped' ? '‚è≠Ô∏è' : '‚úÖ' });
              } else {
                results.push({ name: pattern, emoji: '‚ùå' });
                anyFailed = true;
              }
            }

            // Get current labels
            const { data: labels } = await github.rest.issues.listLabelsOnIssue({ owner, repo, issue_number: prNumber });
            const labelNames = labels.map(l => l.name);
            const currentReview = REVIEW_LABELS.find(l => labelNames.includes(l)) || 'None';

            // Determine and update status
            let newStatus = STATUS.CHECKING;
            if (allComplete) newStatus = anyFailed ? STATUS.FAILED : STATUS.PASSED;

            const currentStatus = Object.values(STATUS).find(s => labelNames.includes(s));
            if (currentStatus !== newStatus) {
              for (const s of Object.values(STATUS)) {
                if (labelNames.includes(s)) {
                  try { await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: s }); } catch (e) {}
                }
              }
              await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: [newStatus] });
            }

            // Build and post report
            const passedCount = results.filter(r => r.emoji === '‚úÖ' || r.emoji === '‚è≠Ô∏è').length;
            const checksTable = results.map(r => `| ${r.emoji} | ${r.name} |`).join('\n');

            let statusEmoji = 'üîÑ';
            if (allComplete && !anyFailed) statusEmoji = '‚úÖ';
            else if (allComplete && anyFailed) statusEmoji = '‚ùå';

            const body = [
              `## ${statusEmoji} PR Status Report`,
              '',
              '| Label | Value |',
              '|-------|-------|',
              `| CI Status | ${newStatus} |`,
              `| AC Review | ${currentReview} |`,
              '',
              `### CI Checks (${passedCount}/${REQUIRED_PATTERNS.length} passed)`,
              '',
              '| Status | Check |',
              '|--------|-------|',
              checksTable,
              '',
              '---',
              `<sub>Triggered by \`@AutoClaudeCheck\` from @${requestedBy}</sub>`
            ].join('\n');

            await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body });
            console.log(`‚úÖ Posted status report`);

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # SCHEDULED CHECK (every 5 min) - Catch-up, AC labels, auto-check
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  scheduled-check:
    name: Scheduled Check
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    timeout-minutes: 10

    steps:
      - name: Process all open PRs
        uses: actions/github-script@v7
        with:
          retries: 3
          script: |
            const STATUS = { CHECKING: 'üîÑ Checking', PASSED: '‚úÖ Ready for Review', FAILED: '‚ùå Checks Failed' };
            const REVIEW_LABELS = ['Missing AC Approval', 'AC: Approved', 'AC: Changes Requested', 'AC: Blocked', 'AC: Needs Re-review'];
            const AC_PATTERNS = ['ü§ñ Auto Claude PR Review', 'Auto Claude Review', 'Auto-Claude Review'];
            const TRUSTED_BOTS = ['github-actions[bot]', 'auto-claude[bot]'];
            const TRUSTED_ASSOC = ['COLLABORATOR', 'MEMBER', 'OWNER'];
            const REQUIRED_PATTERNS = [
              'CI / test-frontend',
              'CI / test-python (3.12)',
              'CI / test-python (3.13)',
              'Lint / python',
              'Quality Security / CodeQL (javascript-typescript)',
              'Quality Security / CodeQL (python)',
              'Quality Security / Python Security (Bandit)',
              'Quality Security / Security Summary'
            ];

            const { owner, repo } = context.repo;

            // Get all open PRs
            const { data: prs } = await github.rest.pulls.list({
              owner, repo, state: 'open', sort: 'created', direction: 'desc', per_page: 100
            });

            console.log(`Processing ${prs.length} open PR(s)`);
            if (prs.length === 0) return;

            for (const pr of prs) {
              const prNumber = pr.number;
              const ageMinutes = (Date.now() - new Date(pr.created_at).getTime()) / 60000;
              
              console.log(`\n::group::PR #${prNumber} (${Math.floor(ageMinutes)} min old)`);

              // Get labels
              const { data: labels } = await github.rest.issues.listLabelsOnIssue({
                owner, repo, issue_number: prNumber
              });
              const labelNames = labels.map(l => l.name);

              // Helper to update labels
              async function setLabel(allLabels, newLabel) {
                if (labelNames.includes(newLabel)) return;
                for (const l of allLabels) {
                  if (labelNames.includes(l) && l !== newLabel) {
                    try { await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: l }); } catch (e) {}
                  }
                }
                try { 
                  await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: [newLabel] });
                  console.log(`  Added: ${newLabel}`);
                } catch (e) { console.log(`  Failed to add ${newLabel}: ${e.message}`); }
              }

              // 1. Update CI status
              console.log('  [CI Status]');
              const checkRuns = await github.paginate(
                github.rest.checks.listForRef,
                { owner, repo, ref: pr.head.sha, per_page: 100 },
                (response) => response.data
              );

              let allComplete = true;
              let anyFailed = false;
              for (const pattern of REQUIRED_PATTERNS) {
                const check = checkRuns.find(c => c.name.startsWith(pattern));
                if (!check || check.status !== 'completed') allComplete = false;
                else if (check.conclusion !== 'success' && check.conclusion !== 'skipped') anyFailed = true;
              }

              if (allComplete) {
                await setLabel(Object.values(STATUS), anyFailed ? STATUS.FAILED : STATUS.PASSED);
              } else {
                await setLabel(Object.values(STATUS), STATUS.CHECKING);
              }

              // 2. Add "Missing AC Approval" after 3 minutes (if no AC label)
              const hasACLabel = REVIEW_LABELS.some(l => labelNames.includes(l));
              if (ageMinutes >= 3 && !hasACLabel) {
                console.log('  [AC Label] Adding Missing AC Approval (3+ min, no AC label)');
                await setLabel(REVIEW_LABELS, 'Missing AC Approval');
              }

              // 3. Scan comments for Auto Claude verdicts
              console.log('  [AC Verdicts]');
              const { data: comments } = await github.rest.issues.listComments({
                owner, repo, issue_number: prNumber, per_page: 50
              });

              let latestVerdict = null;
              let latestTime = 0;

              for (const comment of comments) {
                const isTrusted = (TRUSTED_BOTS.includes(comment.user.login) && comment.user.type === 'Bot') ||
                                  TRUSTED_ASSOC.includes(comment.author_association);
                if (!isTrusted) continue;

                const body = (comment.body || '').slice(0, 5000);
                const isAC = AC_PATTERNS.some(p => body.includes(p));
                if (!isAC) continue;

                let verdict = null;
                if (/Merge Verdict:\s*‚úÖ/i.test(body) || body.includes('APPROVED')) verdict = 'AC: Approved';
                else if (/Merge Verdict:\s*üü†/.test(body) || body.includes('NEEDS REVISION')) verdict = 'AC: Changes Requested';
                else if (/Merge Verdict:\s*üî¥/.test(body) || body.includes('BLOCKED')) verdict = 'AC: Blocked';

                if (verdict) {
                  const t = new Date(comment.created_at).getTime();
                  if (t > latestTime) {
                    latestVerdict = verdict;
                    latestTime = t;
                  }
                }
              }

              if (latestVerdict && !labelNames.includes(latestVerdict)) {
                console.log(`  Found verdict: ${latestVerdict}`);
                await setLabel(REVIEW_LABELS, latestVerdict);
              }

              // 4. Check for new commits after approval
              if (labelNames.includes('AC: Approved') && latestTime > 0) {
                const { data: commits } = await github.rest.pulls.listCommits({
                  owner, repo, pull_number: prNumber, per_page: 10
                });
                
                const hasNewCommits = commits.some(c => 
                  new Date(c.commit.committer.date).getTime() > latestTime
                );

                if (hasNewCommits) {
                  console.log('  [Re-review] New commits after approval');
                  await setLabel(REVIEW_LABELS, 'AC: Needs Re-review');
                  
                  await github.rest.issues.createComment({
                    owner, repo, issue_number: prNumber,
                    body: '## üîÑ Re-review Required\n\nNew commits were pushed after Auto-Claude approval.\n\nPlease run Auto-Claude review again.'
                  });
                }
              }

              // 5. Auto status report at 30 min (if still missing approval)
              if (ageMinutes >= 30 && ageMinutes < 35 && labelNames.includes('Missing AC Approval')) {
                const hasAutoReport = comments.some(c => c.body?.includes('Auto status check (30 min)'));
                if (!hasAutoReport) {
                  console.log('  [30-min Report]');
                  const passedCount = REQUIRED_PATTERNS.filter(p => {
                    const c = checkRuns.find(cr => cr.name.startsWith(p));
                    return c?.status === 'completed' && (c.conclusion === 'success' || c.conclusion === 'skipped');
                  }).length;

                  const statusEmoji = allComplete ? (anyFailed ? '‚ùå' : '‚úÖ') : 'üîÑ';
                  
                  await github.rest.issues.createComment({
                    owner, repo, issue_number: prNumber,
                    body: `## ${statusEmoji} Auto Status Check (30 min)\n\nThis PR is still missing AC approval.\n\n**CI:** ${passedCount}/${REQUIRED_PATTERNS.length} checks passed\n\n---\n<sub>ü§ñ Auto status check (30 min)</sub>`
                  });
                }
              }

              console.log('::endgroup::');
            }

            console.log(`\n‚úÖ Processed ${prs.length} PR(s)`);

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # AUTO-CLAUDE REVIEW DETECTION (from comments)
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  ac-review-detection:
    name: AC Review Detection
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issue_comment' &&
      github.event.issue.pull_request &&
      !contains(github.event.comment.body, '@AutoClaudeCheck')
    timeout-minutes: 5

    steps:
      - name: Check for Auto-Claude review
        uses: actions/github-script@v7
        with:
          retries: 3
          script: |
            const REVIEW_LABELS = ['Missing AC Approval', 'AC: Approved', 'AC: Changes Requested', 'AC: Blocked', 'AC: Needs Re-review'];
            const AC_PATTERNS = ['ü§ñ Auto Claude PR Review', 'Auto Claude Review', 'Auto-Claude Review'];
            const TRUSTED_BOTS = ['github-actions[bot]', 'auto-claude[bot]'];
            const TRUSTED_ASSOC = ['COLLABORATOR', 'MEMBER', 'OWNER'];

            const { owner, repo } = context.repo;
            const prNumber = context.payload.issue.number;
            const comment = context.payload.comment;
            const body = (comment.body || '').slice(0, 5000);

            // Check if trusted source
            const isTrusted = (TRUSTED_BOTS.includes(comment.user.login) && comment.user.type === 'Bot') ||
                              TRUSTED_ASSOC.includes(comment.author_association);
            
            if (!isTrusted) {
              console.log('Not a trusted source, skipping');
              return;
            }

            // Check if AC comment
            const isAC = AC_PATTERNS.some(p => body.includes(p));
            if (!isAC) {
              console.log('Not an Auto-Claude comment, skipping');
              return;
            }

            // Parse verdict
            let verdict = null;
            if (/Merge Verdict:\s*‚úÖ/i.test(body) || body.includes('Auto Claude Review - APPROVED')) verdict = 'AC: Approved';
            else if (/Merge Verdict:\s*üü†/.test(body) || body.includes('NEEDS REVISION')) verdict = 'AC: Changes Requested';
            else if (/Merge Verdict:\s*üî¥/.test(body) || body.includes('BLOCKED')) verdict = 'AC: Blocked';

            if (!verdict) {
              console.log('Could not parse verdict, skipping');
              return;
            }

            console.log(`PR #${prNumber} - AC verdict: ${verdict}`);

            // Update label
            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner, repo, issue_number: prNumber
            });
            const labelNames = labels.map(l => l.name);

            if (labelNames.includes(verdict)) {
              console.log('Label already set');
              return;
            }

            // Remove old AC labels
            for (const l of REVIEW_LABELS) {
              if (labelNames.includes(l)) {
                try { await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: l }); } catch (e) {}
              }
            }

            await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: [verdict] });
            console.log(`‚úÖ Updated to: ${verdict}`);
