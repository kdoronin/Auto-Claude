/**
 * Architect feature type definitions
 * Types for AI-powered architectural planning workflow
 */

// ============================================
// Status Types
// ============================================

/**
 * Status of an architect session through its lifecycle
 */
export type SessionStatus = 'interview' | 'schemas' | 'modules' | 'tasks' | 'complete';

/**
 * Status of a generated task
 */
export type TaskStatus = 'draft' | 'validated' | 'exported';

/**
 * Complexity estimate for modules
 */
export type ModuleComplexity = 'low' | 'medium' | 'high';

/**
 * Schema/diagram types supported by the architect
 */
export type SchemaType = 'system' | 'entity' | 'flow' | 'component' | 'database' | 'sequence';

/**
 * Role in interview conversation
 */
export type MessageRole = 'user' | 'assistant' | 'system';

// ============================================
// Interview Types
// ============================================

/**
 * A single message in the architect interview conversation
 */
export interface InterviewMessage {
  id: string;
  role: MessageRole;
  content: string;
  timestamp: Date;
  /** Optional thinking content from Claude extended thinking */
  thinking?: string;
  /** Whether this message is still being streamed */
  isStreaming?: boolean;
}

// ============================================
// Schema Types
// ============================================

/**
 * An architectural schema/diagram generated by the AI
 */
export interface ArchitectSchema {
  id: string;
  sessionId: string;
  type: SchemaType;
  title: string;
  /** Mermaid.js diagram code */
  mermaidCode: string;
  /** Version number for tracking schema updates */
  version: number;
  /** Optional description of the schema */
  description?: string;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Result from rendering a Mermaid diagram
 */
export interface DiagramRenderResult {
  svg: string;
  error: string | null;
}

// ============================================
// Module Types
// ============================================

/**
 * A module decomposed from the architecture
 * Represents a logical unit of implementation
 */
export interface ModuleDefinition {
  id: string;
  sessionId: string;
  name: string;
  description: string;
  /** Key responsibilities of this module */
  responsibilities: string[];
  /** Entities/concepts this module handles */
  entities: string[];
  /** IDs of other modules this depends on */
  dependencies: string[];
  estimatedComplexity: ModuleComplexity;
  /** Optional notes from human validation */
  validationNotes?: string;
  /** Whether this module has been validated by user */
  isValidated?: boolean;
}

// ============================================
// Task Types
// ============================================

/**
 * A detailed task generated from a module
 * Can be exported to Kanban Board
 */
export interface ArchitectTask {
  id: string;
  moduleId: string;
  title: string;
  description: string;
  /** Criteria that define when task is complete */
  acceptanceCriteria: string[];
  /** IDs of other tasks this depends on */
  dependencies: string[];
  /** Implementation phase number (for ordering) */
  phase: number;
  /** Estimated effort (e.g., "2-4 hours", "1-2 days") */
  estimatedEffort: string;
  status: TaskStatus;
  /** ID of task in Kanban Board after export */
  kanbanTaskId?: string;
  /** User edits to the task before export */
  userEdits?: {
    title?: string;
    description?: string;
    acceptanceCriteria?: string[];
  };
}

// ============================================
// Session Types
// ============================================

/**
 * A complete architect session
 * Persisted to file storage for large conversation history
 */
export interface ArchitectSession {
  id: string;
  projectName: string;
  /** Optional project description for context */
  projectDescription?: string;
  createdAt: Date;
  updatedAt: Date;
  status: SessionStatus;
  /** Interview conversation history */
  interviewHistory: InterviewMessage[];
  /** Generated architectural schemas */
  schemas: ArchitectSchema[];
  /** Decomposed modules */
  modules: ModuleDefinition[];
  /** Generated implementation tasks */
  tasks: ArchitectTask[];
  /** Whether the session has unsaved changes */
  isDirty?: boolean;
  /** Error message if session encountered an error */
  error?: string;
}

/**
 * Lightweight session metadata for listing sessions
 * Used when we don't need the full conversation history
 */
export interface ArchitectSessionSummary {
  id: string;
  projectName: string;
  status: SessionStatus;
  schemaCount: number;
  moduleCount: number;
  taskCount: number;
  createdAt: Date;
  updatedAt: Date;
}

// ============================================
// Store Types
// ============================================

/**
 * State shape for the Zustand architect store
 */
export interface ArchitectState {
  /** All session summaries (lightweight) */
  sessions: ArchitectSessionSummary[];
  /** Currently active session (full data) */
  currentSession: ArchitectSession | null;
  /** Loading state for async operations */
  isLoading: boolean;
  /** Error message from last operation */
  error: string | null;
  /** Whether interview is currently streaming */
  isStreaming: boolean;
}

/**
 * Actions for the Zustand architect store
 */
export interface ArchitectActions {
  /** Start a new architect session */
  startSession: (projectName: string, projectDescription?: string) => Promise<void>;
  /** Load an existing session by ID */
  loadSession: (sessionId: string) => Promise<void>;
  /** Delete a session */
  deleteSession: (sessionId: string) => Promise<void>;
  /** Add a user message to the interview */
  addMessage: (content: string) => Promise<void>;
  /** Handle incoming streamed message from AI */
  handleStreamMessage: (message: Partial<InterviewMessage>) => void;
  /** Update a schema's content */
  updateSchema: (schemaId: string, content: string) => void;
  /** Validate a module */
  validateModule: (moduleId: string, notes?: string) => void;
  /** Update a task before export */
  updateTask: (taskId: string, updates: Partial<ArchitectTask>) => void;
  /** Validate a task */
  validateTask: (taskId: string) => void;
  /** Export tasks to Kanban Board */
  exportTasksToKanban: (taskIds: string[], kanbanTaskIdMap?: Map<string, string>) => Promise<void>;
  /** Save current session to storage */
  saveSession: () => Promise<void>;
  /** Clear current session */
  clearCurrentSession: () => void;
  /** Set error state */
  setError: (error: string | null) => void;
  /** Clear error state */
  clearError: () => void;
  /** Transition session to next status */
  transitionStatus: (newStatus: SessionStatus) => void;
  /** Regenerate schemas with updated requirements */
  regenerateSchemas: () => Promise<void>;
  /** Generate modules from schemas */
  generateModules: () => Promise<void>;
  /** Generate tasks from modules */
  generateTasks: () => Promise<void>;
}

/**
 * Complete Zustand store type (state + actions)
 */
export type ArchitectStore = ArchitectState & ArchitectActions;

// ============================================
// IPC Types
// ============================================

/**
 * Options for starting an architect interview
 */
export interface ArchitectInterviewOptions {
  prompt: string;
  sessionHistory?: InterviewMessage[];
  sessionId: string;
}

/**
 * Streaming message from Claude via IPC
 */
export interface ArchitectStreamMessage {
  type: 'assistant' | 'thinking' | 'error' | 'done';
  content?: string;
  sessionId: string;
  timestamp: Date;
}

/**
 * Result from parsing AI output for schemas
 */
export interface ParsedSchemaResult {
  schemas: Omit<ArchitectSchema, 'id' | 'sessionId' | 'createdAt' | 'updatedAt' | 'version'>[];
  rawText: string;
  parseErrors?: string[];
}

/**
 * Result from parsing AI output for modules
 */
export interface ParsedModuleResult {
  modules: Omit<ModuleDefinition, 'id' | 'sessionId'>[];
  rawText: string;
  parseErrors?: string[];
}

/**
 * Result from parsing AI output for tasks
 */
export interface ParsedTaskResult {
  tasks: Omit<ArchitectTask, 'id' | 'status' | 'kanbanTaskId'>[];
  rawText: string;
  parseErrors?: string[];
}

// ============================================
// Component Props Types
// ============================================

/**
 * Props for the main ArchitectTab component
 */
export interface ArchitectTabProps {
  /** Optional callback when navigating to a task */
  onNavigateToTask?: (taskId: string) => void;
}

/**
 * Props for the InterviewPanel component
 */
export interface InterviewPanelProps {
  session: ArchitectSession;
  onSendMessage: (content: string) => Promise<void>;
  isStreaming: boolean;
}

/**
 * Props for the SchemaViewer component
 */
export interface SchemaViewerProps {
  schemas: ArchitectSchema[];
  onSchemaSelect?: (schemaId: string) => void;
  selectedSchemaId?: string;
}

/**
 * Props for the ModuleList component
 */
export interface ModuleListProps {
  modules: ModuleDefinition[];
  onValidateModule: (moduleId: string, notes?: string) => void;
}

/**
 * Props for the TaskGenerator component
 */
export interface TaskGeneratorProps {
  tasks: ArchitectTask[];
  modules: ModuleDefinition[];
  onUpdateTask: (taskId: string, updates: Partial<ArchitectTask>) => void;
  onValidateTask: (taskId: string) => void;
  onExportToKanban: (taskIds: string[]) => Promise<void>;
}
